"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = require("ava");
const path_1 = require("path");
const childProcess = require("child_process");
const fs_1 = require("./fs");
const spawn = (parameters) => new Promise((resolve, reject) => {
    const subProcess = childProcess.spawn(parameters.command, parameters.args || [], parameters.options || {})
        .once('error', reject)
        .once('exit', (code) => {
        if (code === 0) {
            resolve();
        }
        else {
            reject(new Error(`The command "${parameters.command}" exited with code ${code}.`));
        }
    });
    if (subProcess.stdout) {
        subProcess.stdout.pipe(parameters.stdout || process.stdout);
    }
    if (subProcess.stderr) {
        subProcess.stderr.pipe(parameters.stderr || process.stderr);
    }
});
const projectRoot = path_1.join(__dirname, '..');
const projectDirectory = path_1.join(projectRoot, 'test/project');
ava_1.default.before(() => __awaiter(this, void 0, void 0, function* () {
    yield spawn({
        command: 'npm run generate',
        options: {
            cwd: projectDirectory,
            shell: true,
        },
    });
    yield spawn({
        command: 'npm run deploy',
        options: {
            cwd: projectDirectory,
            shell: true,
        },
    });
}));
ava_1.default('compare files', (t) => __awaiter(this, void 0, void 0, function* () {
    const publicDirectory = path_1.join(projectDirectory, 'public');
    const s3Directory = path_1.join(projectDirectory, 'test-output/us-east-1/test');
    const testDirectory = (directory) => __awaiter(this, void 0, void 0, function* () {
        yield Promise.all((yield fs_1.readdir(directory)).map((name) => __awaiter(this, void 0, void 0, function* () {
            const file = path_1.join(directory, name);
            const stats = yield fs_1.stat(file);
            if (stats.isDirectory()) {
                yield testDirectory(file);
            }
            else {
                t.log(file);
                const [source, uploaded] = yield Promise.all([
                    fs_1.readFile(file),
                    fs_1.readFile(path_1.join(s3Directory, path_1.relative(publicDirectory, file))),
                ]);
                t.is(uploaded.length, source.length);
                switch (path_1.extname(name)) {
                    case '.txt':
                    case '.html':
                    case '.css':
                    case '.js':
                        t.is(`${uploaded}`, `${source}`);
                        break;
                    default:
                        t.true(Buffer.isBuffer(uploaded) && Buffer.isBuffer(source) && uploaded.equals(source), `Failed: ${file}`);
                }
            }
        })));
    });
    yield testDirectory(publicDirectory);
}));
